apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: conforma-vsa
  namespace: managed-namespace
  labels:
    app.kubernetes.io/name: conforma-vsa
    app.kubernetes.io/component: vsa-generation
    app.kubernetes.io/part-of: konflux-slsa
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/categories: Security
    tekton.dev/displayName: "Conforma VSA Generation"
    tekton.dev/pipelines.minVersion: "0.50.0"
    tekton.dev/platforms: "linux/amd64,linux/arm64"
    tekton.dev/tags: slsa,vsa,policy,attestation
spec:
  description: >-
    Generates SLSA Verification Summary Attestation (VSA) from Conforma policy evaluation
    results in a managed namespace with proper trust boundary separation.
  
  params:
    - name: IMAGES
      type: string
      description: |
        Spec section of an ApplicationSnapshot resource. Example:
        {
          "components": [
            {
              "containerImage": "quay.io/example/repo@sha256:..."
            }
          ]
        }

    - name: POLICY_CONFIGURATION
      type: string
      description: |
        Name of the policy configuration (EnterpriseContractPolicy resource) to use.
        `namespace/name` or `name` syntax supported. Also supports git URLs.
      default: "enterprise-contract-service/default"

    - name: PUBLIC_KEY
      type: string
      description: >-
        Public key used to verify signatures. Must be a valid k8s cosign
        reference, e.g. k8s://my-space/my-secret where my-secret contains
        the expected cosign.pub attribute.
      default: ""

    - name: STRICT
      type: string
      description: Fail the task if policy fails. Set to "false" to disable it.
      default: "true"

    - name: HOMEDIR
      type: string
      description: Value for the HOME environment variable.
      default: /tekton/home

    - name: EFFECTIVE_TIME
      type: string
      description: Run policy checks with the provided time.
      default: "now"

    - name: verifier-id
      type: string
      description: Verifier identifier for VSA
      default: "https://managed.konflux.example.com/conforma-vsa"

  workspaces:
    - name: build-artifacts
      description: Build artifacts from tenant context
      
    - name: vsa-results
      description: VSA output and evidence
      
    - name: signing-config
      description: Managed signing key configuration
      optional: true

  results:
    - name: TEST_OUTPUT
      description: Short summary of the policy evaluation for each image

    - name: vsa-path
      description: Path to generated VSA file

    - name: vsa-digest
      description: SHA256 digest of the generated VSA

  stepTemplate:
    env:
      - name: HOME
        value: "$(params.HOMEDIR)"

  steps:
    - name: write-snapshot
      image: registry.redhat.io/rhtas/ec-rhel9:0.6
      script: |
        #!/bin/bash
        set -euo pipefail

        echo "Writing snapshot to file..."
        echo '$(params.IMAGES)' > $(params.HOMEDIR)/snapshot.json

        echo "Snapshot contents:"
        cat $(params.HOMEDIR)/snapshot.json

    - name: validate
      image: quay.io/conforma/cli:latest
      onError: continue
      command: [ec]
      args:
        - validate
        - image
        - "--verbose"
        - "--images"
        - "$(params.HOMEDIR)/snapshot.json"
        - "--policy"
        - "$(params.POLICY_CONFIGURATION)"
        - "--public-key"
        - "$(params.PUBLIC_KEY)"
        - "--strict=false"
        - "--show-successes"
        - "--effective-time=$(params.EFFECTIVE_TIME)"
        - "--output"
        - "text?show-successes=false"
        - "--output"
        - "appstudio=$(results.TEST_OUTPUT.path)"
        - "--output"
        - "json=$(params.HOMEDIR)/report-json.json"
      computeResources:
        requests:
          cpu: 250m
          memory: 2Gi
        limits:
          memory: 2Gi

    - name: report-json
      image: quay.io/conforma/cli:latest
      onError: continue
      command: [cat]
      args:
        - "$(params.HOMEDIR)/report-json.json"

    - name: convert-to-vsa
      image: golang:1.21-alpine
      script: |
        #!/bin/sh
        set -euo pipefail

        echo "Converting EC JSON output to VSA format..."

        # Install required tools
        apk add --no-cache git

        # Copy converter from workspace
        mkdir -p /tmp/converter
        cp -r /workspace/build-artifacts/managed-context/tasks/conforma-vsa/scripts/* /tmp/converter/ || {
          echo "WARNING: Could not find converter in workspace, using inline converter"
          # Fallback: create minimal converter inline
          cat > /tmp/converter/convert-conforma-to-vsa.go <<'GOEOF'
package main
import (
  "encoding/json"
  "flag"
  "fmt"
  "os"
  "time"
)

type ECReport struct {
  Success bool `json:"success"`
  Components []struct {
    ContainerImage string `json:"containerImage"`
    Success bool `json:"success"`
  } `json:"components"`
}

type VSA struct {
  Type string `json:"_type"`
  PredicateType string `json:"predicateType"`
  Subject []struct {
    Name string `json:"name"`
  } `json:"subject"`
  Predicate struct {
    Verifier struct {
      ID string `json:"id"`
    } `json:"verifier"`
    TimeVerified string `json:"timeVerified"`
    VerificationResult string `json:"verificationResult"`
  } `json:"predicate"`
}

func main() {
  input := flag.String("input", "", "Input EC JSON report")
  output := flag.String("output", "", "Output VSA JSON")
  verifierID := flag.String("verifier-id", "", "Verifier ID")
  flag.Parse()

  data, _ := os.ReadFile(*input)
  var ec ECReport
  json.Unmarshal(data, &ec)

  vsa := VSA{
    Type: "https://in-toto.io/Statement/v1",
    PredicateType: "https://slsa.dev/verification_summary/v1",
  }

  if len(ec.Components) > 0 {
    vsa.Subject = []struct{Name string `json:"name"`}{{Name: ec.Components[0].ContainerImage}}
  }

  vsa.Predicate.Verifier.ID = *verifierID
  vsa.Predicate.TimeVerified = time.Now().UTC().Format(time.RFC3339)
  if ec.Success {
    vsa.Predicate.VerificationResult = "PASSED"
  } else {
    vsa.Predicate.VerificationResult = "FAILED"
  }

  out, _ := json.MarshalIndent(vsa, "", "  ")
  os.WriteFile(*output, out, 0644)
  fmt.Printf("VSA written to %s\n", *output)
}
GOEOF
          cat > /tmp/converter/go.mod <<'MODEOF'
module converter
go 1.21
MODEOF
        }

        cd /tmp/converter
        go build -o convert-conforma-to-vsa convert-conforma-to-vsa.go

        # Run conversion
        mkdir -p $(dirname $(params.HOMEDIR)/vsa.json)
        ./convert-conforma-to-vsa \
          -input $(params.HOMEDIR)/report-json.json \
          -output $(params.HOMEDIR)/vsa.json \
          -verifier-id "$(params.verifier-id)"

        echo "VSA generated at $(params.HOMEDIR)/vsa.json"
        cat $(params.HOMEDIR)/vsa.json

        # Set results
        echo -n "$(params.HOMEDIR)/vsa.json" | tee $(results.vsa-path.path)
        VSA_DIGEST=$(sha256sum $(params.HOMEDIR)/vsa.json | cut -d' ' -f1)
        echo -n "$VSA_DIGEST" | tee $(results.vsa-digest.path)

    - name: sign-vsa
      image: gcr.io/projectsigstore/cosign:v2.2.4
      script: |
        #!/bin/sh
        set -euo pipefail

        echo "Signing VSA with cosign..."

        # Extract first image from snapshot
        FIRST_IMAGE=$(cat $(params.HOMEDIR)/snapshot.json | jq -r '.components[0].containerImage')

        if [ -z "$FIRST_IMAGE" ]; then
          echo "ERROR: No image found in snapshot"
          exit 1
        fi

        echo "Attesting to image: $FIRST_IMAGE"

        # Check if signing key exists
        if [ ! -f "/workspace/signing-config/cosign.key" ]; then
          echo "WARNING: No signing key found at /workspace/signing-config/cosign.key"
          echo "Skipping signature - VSA generated but not signed"
          exit 0
        fi

        # Sign and attach VSA attestation
        cosign attest \
          --key /workspace/signing-config/cosign.key \
          --type https://slsa.dev/verification_summary/v1 \
          --predicate $(params.HOMEDIR)/vsa.json \
          "$FIRST_IMAGE"

        echo "VSA signed and attached to image"
      env:
        - name: COSIGN_PASSWORD
          valueFrom:
            secretKeyRef:
              name: cosign-signing-keys
              key: cosign.password
              optional: true

    - name: assert
      image: quay.io/conforma/cli:latest
      command: [jq]
      args:
        - "--argjson"
        - "strict"
        - "$(params.STRICT)"
        - "-e"
        - >
          .result == "SUCCESS" or .result == "WARNING" or ($strict | not)
        - "$(results.TEST_OUTPUT.path)"